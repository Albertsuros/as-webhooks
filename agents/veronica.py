import os
from dotenv import load_dotenv
from openai import OpenAI
import requests
import re
from flask import request
from datetime import datetime

load_dotenv()

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))
sessions = {}

def completar_datos(session_id, mensaje):
    """Extraer datos del cliente desde el mensaje de voz"""
    try:
        if session_id not in sessions:
            sessions[session_id] = {
                'nombre': '',
                'telefono': '',
                'email': '',
                'empresa': '',
                'notas': ''
            }
        
        datos = sessions[session_id]
        mensaje_lower = mensaje.lower()
        
        # Detectar nombre
        if "me llamo" in mensaje_lower or "soy" in mensaje_lower:
            if "me llamo" in mensaje_lower:
                partes = mensaje_lower.split("me llamo")
                if len(partes) > 1:
                    nombre = partes[1].strip().split()[0]
                    if nombre:
                        datos["nombre"] = nombre.title()
            elif "soy" in mensaje_lower:
                partes = mensaje_lower.split("soy")
                if len(partes) > 1:
                    nombre = partes[1].strip().split()[0]
                    if nombre:
                        datos["nombre"] = nombre.title()
        
        # Detectar tel√©fono (9 d√≠gitos m√≠nimo)
        telefono_match = re.search(r'\b[6-9]\d{8}\b', mensaje)
        if telefono_match:
            datos["telefono"] = telefono_match.group()
        
        # Detectar email
        email_match = re.search(r'[\w\.-]+@[\w\.-]+\.\w+', mensaje)
        if email_match:
            datos["email"] = email_match.group()
        
        # Detectar empresa
        empresa_patterns = [
            r'(?:empresa|compa√±√≠a|trabajo en)\s+([^,\.]+)',
            r'(?:de la empresa|en)\s+([A-Z][a-zA-Z\s]+)'
        ]
        for pattern in empresa_patterns:
            empresa_match = re.search(pattern, mensaje, re.IGNORECASE)
            if empresa_match:
                datos["empresa"] = empresa_match.group(1).strip()
                break
        
        # Agregar notas adicionales
        if not any(datos.values()):  # Si no se captur√≥ nada espec√≠fico
            datos["notas"] += f" {mensaje}"
        
        # Debug
        print(f"üîç DEBUG Ver√≥nica - Mensaje: {mensaje}")
        print(f"üîç DEBUG Ver√≥nica - Datos extra√≠dos: {datos}")
        
        # Verificar si est√°n completos (al menos nombre Y tel√©fono)
        completos = bool(datos["nombre"] and datos["telefono"])
        
        sessions[session_id] = datos
        return datos, completos
        
    except Exception as e:
        print(f"‚ùå Error completar_datos Ver√≥nica: {e}")
        return sessions.get(session_id, {}), False

def handle_veronica_webhook(data):
    try:
        # Fix anti-loop
        if not data or not isinstance(data, dict):
            return {"status": "ok"}
        
        user_text = data.get('text', '').strip()
        session_id = data.get("session_id")
        
        # Healthcheck
        if not user_text and not session_id:
            print("ü•Ω HEALTHCHECK detectado - respondiendo silenciosamente")
            return {"status": "ok"}
        
        if request.method != 'POST':
            return {"status": "ok", "message": "Veronica webhook ready"}
        
        if not user_text or len(user_text.strip()) < 3:
            print("‚ö†Ô∏è Request sin contenido real")
            return {"status": "ok"}
        
        print(f"=== VER√ìNICA WEBHOOK ===")
        print(f"Session ID: {session_id}")
        print(f"Mensaje: {user_text}")
        # DEBUG ADICIONAL
        print(f"üîç DEBUG - Funci√≥n ejecutada correctamente")
        print(f"üîç DEBUG - Session ID: {session_id}")
        print(f"üîç DEBUG - Texto limpio: '{mensaje_usuario}'")
        
        # Completar datos del cliente
        datos, completos = completar_datos(session_id, user_text)
        
        if completos:
            print(f"‚úÖ DATOS COMPLETOS: {datos}")
            
            # Enviar notificaci√≥n Telegram con datos
            mensaje_telegram = f"""
ü§ñ <b>NUEVA CONSULTA - AS ASESORES</b>

üë§ <b>Cliente:</b> {datos.get('nombre', 'Sin nombre')}
üè¢ <b>Empresa:</b> {datos.get('empresa', 'Sin empresa')}
üìû <b>Tel√©fono:</b> {datos.get('telefono', 'Sin tel√©fono')}
üìß <b>Email:</b> {datos.get('email', 'Sin email')}
üìù <b>Notas:</b> {datos.get('notas', 'Sin notas')}

üë©‚Äçüíº <b>Agente:</b> Ver√≥nica
‚è∞ <b>Hora:</b> {datetime.now().strftime('%H:%M:%S')}
‚úÖ <b>Estado:</b> Registrado para seguimiento
            """.strip()
            
            enviar_telegram_mejora(mensaje_telegram)
            
            return {"type": "speak", "text": "Perfecto. He registrado todos tus datos. Te contactaremos pronto para ayudarte."}
        else:
            # Pedir m√°s datos
            if not datos.get('nombre'):
                return {"type": "speak", "text": "¬øPuedes decirme tu nombre, por favor?"}
            elif not datos.get('telefono'):
                return {"type": "speak", "text": "¬øCu√°l es tu n√∫mero de tel√©fono de contacto?"}
            else:
                return {"type": "speak", "text": "¬øHay algo m√°s que quieras a√±adir sobre tu consulta?"}

    except Exception as e:
        print(f"‚ùå Error en handle_veronica_webhook: {e}")
        return {"status": "ok"}
        
def enviar_telegram_mejora(mensaje):
    """Enviar notificaci√≥n por Telegram"""
    try:
        bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
        chat_id = os.getenv("TELEGRAM_CHAT_ID")
        
        if not bot_token or not chat_id:
            print("‚ùå Token o Chat ID de Telegram no configurados")
            return False
        
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        data = {
            "chat_id": chat_id,
            "text": mensaje,
            "parse_mode": "HTML"
        }
        
        response = requests.post(url, data=data)
        
        if response.status_code == 200:
            print("‚úÖ Notificaci√≥n Telegram enviada (Ver√≥nica)")
            return True
        else:
            print(f"‚ùå Error enviando Telegram: {response.status_code}")
            return False
            
    except Exception as e:
        print(f"‚ùå Error en notificaci√≥n Telegram: {e}")
        return False
        
# ========================================
# FUNCIONES AGENDAMIENTO VER√ìNICA
# ========================================

def obtener_horarios_veronica(tipo_cita, fecha_solicitada):
    """Obtener horarios disponibles para Ver√≥nica"""
    try:
        from logica_citas_inteligente import obtener_horarios_disponibles_inteligentes
        
        tipo_servicio = f"veronica_{tipo_cita}"  # veronica_presencial o veronica_telefono
        horarios, fecha_final = obtener_horarios_disponibles_inteligentes(tipo_servicio, fecha_solicitada)
        
        return horarios, fecha_final
        
    except Exception as e:
        print(f"‚ùå Error horarios Ver√≥nica: {e}")
        return [], fecha_solicitada

def agendar_cita_veronica(datos_cliente, tipo_cita, fecha, horario):
    """Agendar cita con Ver√≥nica (presencial o tel√©fono)"""
    try:
        from logica_citas_inteligente import agendar_cita_inteligente
        
        tipo_servicio = f"veronica_{tipo_cita}"
        
        exito, resultado = agendar_cita_inteligente(
            tipo_servicio, fecha, horario, datos_cliente
        )
        
        if exito:
            # Enviar notificaci√≥n Telegram
            enviar_telegram_mejora(f"""
üìÖ <b>NUEVA CITA - AS ASESORES</b>

üë§ <b>Cliente:</b> {datos_cliente.get('nombre', 'Sin nombre')}
üìß <b>Email:</b> {datos_cliente.get('email', 'Sin email')}
üìû <b>Tel√©fono:</b> {datos_cliente.get('telefono', 'Sin tel√©fono')}
üéØ <b>Tipo:</b> {"Presencial" if tipo_cita == "presencial" else "Tel√©fono"}
üìÖ <b>Fecha:</b> {fecha.strftime('%d/%m/%Y')}
‚è∞ <b>Horario:</b> {horario}
üî¢ <b>C√≥digo:</b> {resultado}

‚úÖ <b>Estado:</b> Confirmada
            """.strip())
        
        return exito, resultado
        
    except Exception as e:
        print(f"‚ùå Error agendando cita Ver√≥nica: {e}")
        return False, str(e)

def enviar_telegram_mejora(mensaje):
    """Enviar notificaci√≥n por Telegram (igual que en main.py)"""
    try:
        import os
        import requests
        
        bot_token = os.getenv("TELEGRAM_BOT_TOKEN")
        chat_id = os.getenv("TELEGRAM_CHAT_ID")
        
        if not bot_token or not chat_id:
            print("‚ùå Token o Chat ID de Telegram no configurados")
            return False
        
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        data = {
            "chat_id": chat_id,
            "text": mensaje,
            "parse_mode": "HTML"
        }
        
        response = requests.post(url, data=data)
        
        if response.status_code == 200:
            print("‚úÖ Notificaci√≥n Telegram enviada (Ver√≥nica)")
            return True
        else:
            print(f"‚ùå Error enviando Telegram: {response.status_code}")
            return False
            
    except Exception as e:
        print(f"‚ùå Error en notificaci√≥n Telegram: {e}")
        return False
        
def crear_cita_google_calendar(datos):
    """Crear cita en Google Calendar cuando Ver√≥nica recoge datos completos"""
    try:
        from datetime import datetime, timedelta
        
        # Crear cita para ma√±ana (o pr√≥ximo d√≠a laboral)
        ma√±ana = datetime.now() + timedelta(days=1)
        
        # Si es viernes, programar para lunes
        if ma√±ana.weekday() == 5:  # S√°bado
            ma√±ana += timedelta(days=2)
        elif ma√±ana.weekday() == 6:  # Domingo  
            ma√±ana += timedelta(days=1)
        
        # Determinar tipo de cita seg√∫n servicio
        servicio = datos.get('servicio', '').lower()
        if 'telefono' in servicio or 'llamada' in servicio:
            tipo_cita = 'veronica_telefono'
            duracion = 30
        else:
            tipo_cita = 'veronica_presencial' 
            duracion = 90
            
        # Crear evento usando funci√≥n de main.py
        from main import crear_evento_calendar
        
        exito, evento_id = crear_evento_calendar(
            tipo=tipo_cita,
            nombre=datos.get('nombre', 'Cliente'),
            telefono=datos.get('telefono', ''),
            fecha=ma√±ana.strftime('%Y-%m-%d'),
            horario='10:00-11:00',  # Horario por defecto
            codigo='',
            direccion=''
        )
        
        if exito:
            print(f"‚úÖ Cita creada en Google Calendar: {evento_id}")
            # Notificar por Telegram
            enviar_telegram_mejora(f"""
üìÖ <b>NUEVA CITA AGENDADA</b>
üë§ <b>Cliente:</b> {datos.get('nombre', 'Sin nombre')}
üìû <b>Tel√©fono:</b> {datos.get('telefono', 'Sin tel√©fono')}
üìß <b>Email:</b> {datos.get('email', 'Sin email')}
üéØ <b>Servicio:</b> {datos.get('servicio', 'Consulta general')}
üìÖ <b>Fecha:</b> {ma√±ana.strftime('%d/%m/%Y')}
‚è∞ <b>Horario:</b> 10:00-11:00
üÜî <b>Evento:</b> {evento_id}
            """)
        else:
            print(f"‚ùå Error creando cita: {evento_id}")
            
    except Exception as e:
        print(f"‚ùå Error en crear_cita_google_calendar: {e}")
